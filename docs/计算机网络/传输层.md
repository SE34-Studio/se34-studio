> Author : ZHY、CG、WZF
>

## ![](https://cdn.nlark.com/yuque/0/2025/png/57074993/1748324698746-8c0ad882-7acd-411c-a1eb-7557327a6f59.png)传输层概述
**传输层**是OSI七层模型中的**第四层**，在**网络层**之上，**应用层**之下。作用主要是提供进程间的端到端通信服务。它的核心任务是：**让两个主机上的应用程序能够稳定通信**，即提供**进程到进程（process-to-process）**的通信能力。

举个例子：

你用浏览器访问网页：浏览器 = 应用进程，它要通过网络和远程服务器的Web服务进程通信。

网络层只管把数据从一台机器送到另一台机器（主机到主机），但**具体哪个进程处理数据，就是传输层来负责的**

---

## 常见协议：TCP 和 UDP
**TCP（Transmission Control Protocol）**

**面向连接**：通信前需建立连接（三次握手）。

**可靠传输**：有确认机制、重传机制，数据不会乱序或丢失。

**面向字节流**：数据看作一个连续的字节流发送，接收端自行划分。

**适合应用**：如网页浏览（HTTP/HTTPS）、文件传输（FTP）、电子邮件（SMTP/IMAP）。

**UDP（User Datagram Protocol）**

**无连接**：发送数据前不建立连接，**直接发送**。

**不可靠传输**：不保证顺序、不保证到达、不重传。

**面向报文**：一条一条独立的数据包（datagram）传输。

**适合应用**：如**视频会议、语音通话、在线直播、DNS 查询**等。

---

## 关键术语详解
**端口号（Port）**

用于标识同一台主机上不同的应用进程。

一台主机可以有多个应用程序在运行，每个监听不同的端口号。

**端口号范围**：0~65535

+ 0~1023：**知名端口**（well-known ports），如 HTTP：80，HTTPS：443
+ 1024~49151：注册端口，一般用于系统分配给用户程序
+ 49152~65535：动态/私有端口，客户端临时使用

**举例**：

> 浏览器访问网页：客户端随机端口 → 服务器 80 端口
>

**套接字（Socket）**

传输层通信的唯一标识，由「IP地址 + 端口号」构成。

**全双工通信**：每一条连接由两端的 Socket 共同标识。如：`客户端Socket（192.168.1.10:50000） ↔ 服务器Socket（192.168.1.20:80）`

Socket 是进程间通信的桥梁，程序员在编程时主要操作的就是 Socket。

---

## 概述总结
| 内容 | 说明 |
| :---: | :---: |
| 传输层作用 | 连接主机中的进程，实现端到端通信 |
| 常见协议 | TCP（可靠、连接）、UDP（不可靠、无连接） |
| 端口号 | 区分主机内不同进程（如 HTTP 是 80 端口） |
| 套接字 | Socket = IP + Port，唯一标识一条通信连接 |


---

## TCP的三次握手
### 目的：
+ 建立可靠连接（双方准备就绪）
+ 确认通信双方的**发送**和**接收能力**都正常

### 过程：
**第一次握手**：

+ **客户端 → 服务端**
+ 发送一个**SYN报文段**，请求建立连接
    - `**Seq = x**`（初始序号，由客户端随机产生）
+ 此时客户端状态：`CLOSED → SYN_SENT`

**第二次握手**：

+ **服务端 → 客户端**
+ 回复一个**SYN + ACK 报文段**，表示同意连接
    - `**SYN**`：表示我也想建立连接
    - `**ACK = x + 1**`：确认收到了客户端的 SYN
    - `**Seq = y**`：服务端自己的初始序号
+ 服务端状态：`CLOSED → SYN_RCVD`

**第三次握手**：

+ **客户端 → 服务端**
+ 回复一个**ACK 报文段**
    - `**ACK = y + 1**`确认收到了服务端的 SYN
+ 此时双方状态变为：`ESTABLISHED`，连接建立成功！

![](https://cdn.nlark.com/yuque/0/2025/jpeg/52786312/1748254224607-24fc8fd2-6993-4f59-b1e7-4cf18c25584a.jpeg)

### 常考细节说明：
| 项目 | 说明 |
| :---: | :---: |
| **SYN** | 连接请求标志位 |
| **ACK** | 确认标志位，说明接收到了数据 |
| **Seq** | 序号，表示当前发出去的数据编号 |
| **Ack** | 确认号，表示“期望接收对方下一个字节的序号” |
| **为什么是三次？** | 需要双向确认：客户端确认服务端收到了自己的请求，服务端也确认客户端能收数据 |


### 关注点：
+ 每次的 Seq、Ack 值的计算
+ 谁先发，谁确认谁的 ACK
+ 状态转换（CLOSED → SYN_SENT → ESTABLISHED 等）

---

## TCP的四次挥手
**目的**：关闭连接，让双方都能“优雅退出”

**过程**：

**第一次挥手**：

+ 客户端 → 服务端
+ 发送一个**FIN 报文段**，表示客户端没有数据要发送了，但仍可以接收数据`**Seq = u**`
+ 状态：客户端变为 `FIN_WAIT_1`

**第二次挥手**：

+ 服务端 → 客户端
+ 回复一个ACK 报文段`Ack = u + 1` 表示“我知道你想断开，但我还有事要处理”
+ 客户端状态变为 `FIN_WAIT_2`，等待服务端发 FIN
+ 服务端状态变为 `CLOSE_WAIT`

**第三次挥手**：

+ **服务端 → 客户端**
+ 等待数据发完后，发送**FIN 报文段 **`**Seq = v**`表示“**我也发完了**”
+ 服务端状态变为 `LAST_ACK`

**第四次挥手**：

+ **客户端 → 服务端**
+ 回复一个 **ACK 报文段 **`**Ack = v + 1**`
+ 然后进入 `TIME_WAIT` 状态，等待** 2MSL（最大报文生存时间）**后真正关闭
+ 服务端接收 ACK 后关闭连接

### 常考细节说明
| 项目 | 说明 |
| :---: | :---: |
| **为什么是四次？** | TCP 是全双工的：发送和接收要分别关闭，每方向都要用一个 FIN-ACK |
| **TIME_WAIT** | 保证 ACK 能成功送达，也防止旧连接数据影响新连接 |
| **CLOSE_WAIT** | 服务端收到 FIN 后还没关，要先处理完自己的数据 |


---

### 三次握手与四次挥手小结对比：
| 项目 | 三次握手 | 四次挥手 |
| :---: | :---: | :---: |
| 作用 | 建立连接 | 关闭连接 |
| 报文数量 | 3 | 4 |
| 连接状态 | CLOSED → ESTABLISHED | ESTABLISHED → CLOSED |
| 特殊状态 | SYN_SENT、SYN_RCVD | FIN_WAIT_1、TIME_WAIT、CLOSE_WAIT |


---

## TCP 的流量控制（Flow Control）
### 目的：
防止**接收方来不及处理**数据，导致**丢包**或资源崩溃。

> **类比：你是快递员（发送方），我（接收方）家门口就一个小箱子，我没来得及清理你就一直送快递，最后就爆了。→ 所以你送前得问我：“你现在能接几个快递？”**
>

**实现机制：滑动窗口（Sliding Window）**

接收方告诉发送方：“我还有多少接收空间（窗口大小）”，发送方就控制发送量。

**窗口大小**：称为 **rwnd（receiver window）**，由接收方在 ACK 中携带告知发送方。

如果 rwnd = 0，发送方就暂停发送，等待接收方窗口打开（用一个特例的**窗口探测包**测试是否可恢复发送）。

### 核心点总结：
| 项目 | 说明 |
| :---: | :---: |
| 控制对象 | 接收方 → 发送方 |
| 核心机制 | 滑动窗口（接收方控制发送速度） |
| 关键变量 | rwnd：接收方剩余缓冲区大小 |
| 特殊情况 | 接收方窗口为 0，发送方必须停止发送，定期探测恢复 |


---

## TCP 的拥塞控制（Congestion Control）
**目的：**

防止**整个网络中**因为数据过多而发生拥塞，造成严重丢包、延迟。

类比：高速公路车太多堵住了 → 就算你车速快，整体网络也崩 → 所以大家要限速。

**控制对象：**

**发送方**根据网络状况**自我约束**，慢慢增加速率，一旦发现网络出问题就减速。

**核心变量：**

**cwnd（拥塞窗口）**：发送方控制速率的主要参数

实际发送窗口大小 = `min(rwnd, cwnd)`  
（同时受到接收方和网络的双重限制）

### 四个核心算法详解：
1. **慢开始（Slow Start）**

初始 cwnd = 1 MSS（最大报文段大小）

每收到一个 ACK，**cwnd 翻倍**（指数增长）

一直到 cwnd 达到一个阈值 `ssthresh`，进入下一个阶段

避免一开始就把网络“吓坏”

2. **拥塞避免（Congestion Avoidance）**

cwnd ≥ ssthresh 后，增长速度变慢

每轮 RTT 只加 1 MSS（线性增长）

3. **快速重传（Fast Retransmit）**

收到 **三个重复 ACK**，认为丢包了，马上重传丢失段（不用等超时）

说明部分数据还是能收，网络不完全挂

4. **快速恢复（Fast Recovery）**

结合快速重传使用

**重传后** 

+ ssthresh = cwnd / 2（减半） 
+ cwnd 也降到 ssthresh，然后转入“拥塞避免”

### 常考组合题说明：
| 情况 | cwnd变化方式 | ssthresh变化方式 |
| :---: | :---: | :---: |
| 正常发送 | 慢开始（指数增长）或线性增加 | 不变 |
| 超时重传 | cwnd = 1，ssthresh = cwnd / 2 | → 回到慢开始 |
| 三个重复ACK | 快速重传 + 快速恢复 | ssthresh = cwnd / 2，进入拥塞避免 |


---

## 总结比较表 流量控制与拥塞控制
| 控制类型 | 流量控制 | 拥塞控制 |
| :---: | :---: | :---: |
| 控制对象 | 接收方 | 网络 |
| 作用 | 防止接收方被压垮 | 防止网络过载 |
| 控制变量 | rwnd（接收窗口） | cwnd（拥塞窗口） |
| 控制主体 | 接收方通过 ACK 控制发送方 | 发送方根据网络情况自我调整 |
| 典型机制 | 滑动窗口 | 慢开始、拥塞避免、快重传、快恢复 |


---

## UDP协议
### 特点
UDP（User Datagram Protocol，用户数据报协议）是一个非常轻量的传输层协议，它的主要特点如下：

**无连接**：发送方和接收方之间不需要建立连接，数据可以直接发送过去。这也意味着它不需要像 TCP 那样进行握手（三次握手）。

**不可靠**：UDP 不保证数据一定能送达目的地，发送之后不会确认，也不会重发丢失的数据。

**面向数据报**：每个 UDP 消息称为一个“数据报（datagram）”，它是一个完整的、独立的传输单位。发送多少个数据报，对方就接收到多少个（如果没有丢的话）。

**不保证顺序**：发送的数据报在传输过程中可能被网络以不同的路径送达，所以顺序可能乱。

**不重传**：数据一旦丢失，UDP 不会尝试重新发送（除非应用层自己实现了机制）。

### **优点**
尽管不可靠，但 UDP 在某些场景中非常有用，主要优点有：

**传输速度快**：由于没有连接建立、无需确认和重传，UDP 的处理过程非常简单，延迟低、速度快。

**开销小**：UDP 头部只有 8 字节，而 TCP 至少 20 字节，并且还要维护连接状态、滑动窗口、序列号等，UDP 不需要这些，资源消耗更小。

**适用于实时场景**：比如视频会议、在线直播、在线游戏等，对于实时性要求高、但即使少量数据丢失也能容忍的应用；或者像 DNS 查询这样的应用，即使一次失败也可以重试，对可靠性要求不高。

---

## UDP 与 TCP 的对比
| 特性 | TCP（传输控制协议） | UDP（用户数据报协议） |
| :---: | :---: | :---: |
| 连接类型 | 面向连接（需三次握手） | 无连接（无需建立连接） |
| 可靠性 | 有确认机制，保证可靠性 | 不确认，不保证可靠性 |
| 顺序保障 | 有序传输（按序号排序） | 可能乱序 |
| 开销 | 开销较大（维护连接状态） | 开销小（头部简单，无连接） |
| 应用场景 | 例如 HTTP、FTP、SMTP | 例如 视频会议、语音、DNS |


**更形象地理解**

**TCP** 就像是寄快递，必须确认地址、签收、包装、如果掉了还得重新寄，**比较慢但很稳**。

**UDP** 就像是写明信片，写好了直接投邮筒，**不管收没收到、顺不顺序，图个快**。

---

## Socket
**定义**

**Socket（套接字）** 是一种通信机制，可以让两个程序（可能在不同主机上）通过网络进行数据交换。

可以把它看作是一个网络通信的“插口”或者“端点”。

一个完整的 Socket 标识包含：`**IP 地址 + 端口号**`** **这样才能唯一标识网络中的某一个通信端。

**通信过程**

通信的双方（比如客户端和服务器）都通过各自的 Socket 来进行数据收发。

**本地通信（IPC）**：同一台电脑上两个进程间的通信（可以用 Socket）。

**远程通信**：不同主机上的进程之间通过网络通信（最常见用途）。

**Socket 编程常用函数对照表（客户端 & 服务端）**

| 类别 | 函数名 | 作用简述 |
| :---: | :---: | :---: |
| 通用 | `socket()` | 创建一个套接字（Socket），返回文件描述符 |
| 通用 | `close()` | 关闭一个打开的 Socket |
| 服务端 | `bind()` | 绑定 IP 地址和端口号到套接字上 |
| 服务端 | `listen()` | 将套接字设置为监听状态，准备接受连接请求 |
| 服务端 | `accept()` | 接受客户端的连接请求，返回一个新的用于通信的套接字 |
| 客户端 | `connect()` | 连接到服务器的套接字（需要服务器 IP 和端口） |
| 双方通用 | `send()` | 发送数据，通过 Socket 发给对方 |
| 双方通用 | `recv()` | 接收数据，从 Socket 中读取数据 |
| 可选 | `inet_pton()` | 将字符串格式的 IP 地址转为网络格式（二进制） |
| 可选 | `inet_ntop()` | 将网络格式（二进制）的 IP 地址转为字符串格式 |
| 可选 | `setsockopt()` | 设置套接字选项（如复用端口等） |


